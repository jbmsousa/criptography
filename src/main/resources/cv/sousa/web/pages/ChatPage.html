<!DOCTYPE html>
<html xmlns:wicket="http://wicket.apache.org">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title wicket:id="pageTitle">Chat - Secure Messaging</title>
    <style>
        .chat-container {
            height: 60vh;
            overflow-y: auto;
            border: 1px solid #dee2e6;
            border-radius: 0.375rem;
            padding: 1rem;
            background: #f8f9fa;
        }
        .message {
            max-width: 70%;
            margin-bottom: 1rem;
            padding: 0.75rem 1rem;
            border-radius: 1rem;
        }
        .message.sent {
            background: #0d6efd;
            color: white;
            margin-left: auto;
            border-bottom-right-radius: 0.25rem;
        }
        .message.received {
            background: white;
            border: 1px solid #dee2e6;
            border-bottom-left-radius: 0.25rem;
        }
        .message-time {
            font-size: 0.75rem;
            opacity: 0.7;
        }
        .typing-indicator {
            font-style: italic;
            color: #6c757d;
        }
    </style>
</head>
<body class="bg-light">
    <nav wicket:id="navbar"></nav>

    <main class="container mt-4">
        <div class="row">
            <div class="col-12">
                <nav aria-label="breadcrumb">
                    <ol class="breadcrumb">
                        <li class="breadcrumb-item"><a href="/dashboard">Dashboard</a></li>
                        <li class="breadcrumb-item active" aria-current="page" wicket:id="chatPartner">Chat</li>
                    </ol>
                </nav>
            </div>
        </div>

        <div class="row">
            <div class="col-12">
                <div class="card shadow">
                    <div class="card-header bg-primary text-white d-flex justify-content-between align-items-center">
                        <div>
                            <i class="bi bi-chat-dots"></i>
                            Chat with <strong id="partnerName" wicket:id="chatPartnerId"></strong>
                            <span id="partnerStatus" class="badge bg-secondary ms-2">Offline</span>
                        </div>
                        <div>
                            <span id="encryptionStatus" class="badge bg-success">
                                <i class="bi bi-lock"></i> E2E Encrypted
                            </span>
                        </div>
                    </div>

                    <div class="card-body">
                        <div wicket:id="chatPanel">
                            <div class="chat-container" id="chatMessages">
                                <!-- Messages will be loaded here -->
                            </div>

                            <div id="typingIndicator" class="typing-indicator d-none mt-2">
                                Partner is typing...
                            </div>

                            <form wicket:id="messageForm" id="messageForm" class="mt-3">
                                <div class="input-group">
                                    <textarea wicket:id="messageInput" id="messageInput" class="form-control"
                                              placeholder="Type your message..." rows="2"></textarea>
                                    <button type="submit" class="btn btn-primary" id="sendBtn">
                                        <i class="bi bi-send"></i> Send
                                    </button>
                                </div>
                            </form>
                        </div>
                    </div>

                    <div class="card-footer text-muted small">
                        <i class="bi bi-shield-lock"></i> Messages are encrypted end-to-end using AES-256-GCM
                        <span id="sessionInfo" class="float-end"></span>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <script>
        const authToken = localStorage.getItem('authToken');
        const currentUserId = localStorage.getItem('userId');
        const chatPartnerId = document.getElementById('partnerName').textContent.trim();
        const ecdhPrivateKeyB64 = localStorage.getItem('ecdhPrivateKey');
        const rsaPrivateKeyB64 = localStorage.getItem('rsaPrivateKey');

        if (!authToken) {
            window.location.href = '/login';
        }

        let ws;
        let sessionKey = null;
        let partnerPublicKey = null;

        // Import private key for ECDH
        async function importEcdhPrivateKey(keyB64) {
            const keyData = Uint8Array.from(atob(keyB64), c => c.charCodeAt(0));
            return await window.crypto.subtle.importKey(
                'pkcs8', keyData,
                { name: 'ECDH', namedCurve: 'P-256' },
                false, ['deriveKey', 'deriveBits']
            );
        }

        // Import public key for ECDH
        async function importEcdhPublicKey(keyB64) {
            const keyData = Uint8Array.from(atob(keyB64), c => c.charCodeAt(0));
            return await window.crypto.subtle.importKey(
                'spki', keyData,
                { name: 'ECDH', namedCurve: 'P-256' },
                false, []
            );
        }

        // Derive session key using ECDH
        async function deriveSessionKey(privateKey, publicKey) {
            return await window.crypto.subtle.deriveKey(
                { name: 'ECDH', public: publicKey },
                privateKey,
                { name: 'AES-GCM', length: 256 },
                false, ['encrypt', 'decrypt']
            );
        }

        // Encrypt message with AES-GCM
        async function encryptMessage(message) {
            const iv = window.crypto.getRandomValues(new Uint8Array(12));
            const encodedMessage = new TextEncoder().encode(message);

            const ciphertext = await window.crypto.subtle.encrypt(
                { name: 'AES-GCM', iv: iv },
                sessionKey,
                encodedMessage
            );

            return {
                iv: btoa(String.fromCharCode(...iv)),
                ciphertext: btoa(String.fromCharCode(...new Uint8Array(ciphertext)))
            };
        }

        // Decrypt message with AES-GCM
        async function decryptMessage(encryptedData) {
            try {
                const iv = Uint8Array.from(atob(encryptedData.iv), c => c.charCodeAt(0));
                const ciphertext = Uint8Array.from(atob(encryptedData.ciphertext), c => c.charCodeAt(0));

                const decrypted = await window.crypto.subtle.decrypt(
                    { name: 'AES-GCM', iv: iv },
                    sessionKey,
                    ciphertext
                );

                return new TextDecoder().decode(decrypted);
            } catch (e) {
                console.error('Decryption failed:', e);
                return '[Decryption failed]';
            }
        }

        // Add message to chat
        function addMessage(content, isSent, timestamp) {
            const chatContainer = document.getElementById('chatMessages');
            const msgDiv = document.createElement('div');
            msgDiv.className = 'message ' + (isSent ? 'sent' : 'received');
            msgDiv.innerHTML = `
                <div>${content}</div>
                <div class="message-time">${new Date(timestamp).toLocaleTimeString()}</div>
            `;
            chatContainer.appendChild(msgDiv);
            chatContainer.scrollTop = chatContainer.scrollHeight;
        }

        // Load partner's public key
        async function loadPartnerKey() {
            const response = await fetch('/api/keys/' + chatPartnerId);
            if (response.ok) {
                const userData = await response.json();
                partnerPublicKey = await importEcdhPublicKey(userData.ecdhPublicKey);

                // Derive session key
                const myPrivateKey = await importEcdhPrivateKey(ecdhPrivateKeyB64);
                sessionKey = await deriveSessionKey(myPrivateKey, partnerPublicKey);

                document.getElementById('sessionInfo').textContent = 'Session established';
            }
        }

        // Load message history
        async function loadHistory() {
            try {
                const response = await fetch('/api/messages/history/' + chatPartnerId, {
                    headers: { 'Authorization': 'Bearer ' + authToken }
                });
                if (response.ok) {
                    const messages = await response.json();
                    for (const msg of messages) {
                        try {
                            const encrypted = JSON.parse(msg.encryptedContent);
                            const decrypted = await decryptMessage(encrypted);
                            addMessage(decrypted, msg.senderId === currentUserId, msg.sentAt);
                        } catch (e) {
                            addMessage('[Unable to decrypt]', msg.senderId === currentUserId, msg.sentAt);
                        }
                    }
                }
            } catch (err) {
                console.error('Failed to load history:', err);
            }
        }

        // WebSocket connection
        function connectWebSocket() {
            ws = new WebSocket('ws://' + window.location.host + '/chat');

            ws.onopen = () => {
                ws.send(JSON.stringify({ type: 'auth', token: authToken }));
            };

            ws.onmessage = async (event) => {
                const msg = JSON.parse(event.data);

                if (msg.type === 'auth_success') {
                    await loadPartnerKey();
                    await loadHistory();
                } else if (msg.type === 'message' && msg.senderId === chatPartnerId) {
                    try {
                        const encrypted = JSON.parse(msg.encryptedContent);
                        const decrypted = await decryptMessage(encrypted);
                        addMessage(decrypted, false, msg.timestamp);

                        // Send read acknowledgment
                        ws.send(JSON.stringify({
                            type: 'ack',
                            messageId: msg.id,
                            senderId: msg.senderId
                        }));
                    } catch (e) {
                        addMessage('[Unable to decrypt]', false, msg.timestamp);
                    }
                } else if (msg.type === 'typing' && msg.senderId === chatPartnerId) {
                    const indicator = document.getElementById('typingIndicator');
                    if (msg.isTyping) {
                        indicator.classList.remove('d-none');
                    } else {
                        indicator.classList.add('d-none');
                    }
                } else if (msg.type === 'user_status' && msg.userId === chatPartnerId) {
                    document.getElementById('partnerStatus').textContent = msg.isOnline ? 'Online' : 'Offline';
                    document.getElementById('partnerStatus').className =
                        'badge ms-2 ' + (msg.isOnline ? 'bg-success' : 'bg-secondary');
                }
            };

            ws.onclose = () => {
                setTimeout(connectWebSocket, 5000);
            };
        }

        // Send message
        document.getElementById('messageForm').addEventListener('submit', async function(e) {
            e.preventDefault();
            const input = document.getElementById('messageInput');
            const message = input.value.trim();

            if (!message || !sessionKey) return;

            try {
                const encrypted = await encryptMessage(message);

                ws.send(JSON.stringify({
                    type: 'message',
                    recipientId: chatPartnerId,
                    encryptedContent: JSON.stringify(encrypted),
                    sessionId: currentUserId + '-' + chatPartnerId
                }));

                addMessage(message, true, new Date().toISOString());
                input.value = '';
            } catch (err) {
                alert('Failed to send message: ' + err.message);
            }
        });

        // Typing indicator
        let typingTimeout;
        document.getElementById('messageInput').addEventListener('input', function() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'typing',
                    recipientId: chatPartnerId,
                    isTyping: true
                }));

                clearTimeout(typingTimeout);
                typingTimeout = setTimeout(() => {
                    ws.send(JSON.stringify({
                        type: 'typing',
                        recipientId: chatPartnerId,
                        isTyping: false
                    }));
                }, 2000);
            }
        });

        connectWebSocket();
    </script>
</body>
</html>
